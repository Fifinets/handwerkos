/**
 * Attendance Service
 * Manages employee work shifts (clock-in/out, breaks)
 * Independent of project time tracking
 */

import { supabase } from '@/integrations/supabase/client'
import { Database } from '@/integrations/supabase/types'

type Attendance = Database['public']['Tables']['attendance']['Row']
type AttendanceInsert = Database['public']['Tables']['attendance']['Insert']
type AttendanceUpdate = Database['public']['Tables']['attendance']['Update']

export interface AttendanceWithEmployee extends Attendance {
  employees?: {
    id: string
    first_name: string
    last_name: string
  }
}

export interface ClockInParams {
  employeeId: string
  location?: {
    lat: number
    lng: number
    accuracy?: number
  }
  note?: string
}

export interface ClockOutParams {
  attendanceId: string
  location?: {
    lat: number
    lng: number
    accuracy?: number
  }
  note?: string
}

export interface BreakPeriod {
  started_at: string
  ended_at?: string
  duration_minutes?: number
}

export class AttendanceService {
  /**
   * Clock in - Start work shift
   */
  static async clockIn(params: ClockInParams): Promise<Attendance | null> {
    try {
      const { employeeId, location, note } = params
      const now = new Date().toISOString()
      const today = new Date().toISOString().split('T')[0]

      // Check if ANY attendance exists for today (open or closed)
      const { data: todayAttendance } = await supabase
        .from('attendance')
        .select('*')
        .eq('employee_id', employeeId)
        .eq('date', today)
        .maybeSingle()

      if (todayAttendance) {
        console.log('Found existing attendance for today:', todayAttendance)

        // If attendance exists and is still open - return it
        if (!todayAttendance.clock_out) {
          console.log('Attendance is still open (no clock_out) - returning existing')
          return todayAttendance
        }

        // If attendance exists but is already closed - reopen it
        // This allows restarting the workday for testing/correction purposes
        console.log('Attendance is closed. Reopening it. ID:', todayAttendance.id)

        const { data: updateData, error: updateError } = await supabase
          .from('attendance')
          .update({
            clock_out: null,
            status: 'open',
            clock_in: now
          })
          .eq('id', todayAttendance.id)
          .select()
          .single()

        console.log('Update result:', { updateData, updateError })

        if (updateError) {
          console.error('Error reopening attendance:', updateError)
          throw new Error(`Fehler beim Wiedereröffnen: ${updateError.message}`)
        }

        console.log('✅ Attendance reopened successfully')
        return updateData
      } else {
        console.log('No existing attendance for today, creating new one')
      }

      // Get employee's company
      const { data: employee } = await supabase
        .from('employees')
        .select('company_id')
        .eq('id', employeeId)
        .single()

      if (!employee) {
        throw new Error('Employee not found')
      }

      const attendanceData: AttendanceInsert = {
        employee_id: employeeId,
        company_id: employee.company_id,
        date: today,
        clock_in: now,
        clock_in_location: location ? {
          lat: location.lat,
          lng: location.lng,
          accuracy: location.accuracy,
          timestamp: now
        } : null,
        status: 'open',
        note,
        autogenerated: false
      }

      const { data, error } = await supabase
        .from('attendance')
        .insert(attendanceData)
        .select()
        .single()

      if (error) throw error
      return data
    } catch (error) {
      console.error('Clock in error:', error)
      throw error
    }
  }

  /**
   * Clock out - End work shift
   */
  static async clockOut(params: ClockOutParams): Promise<Attendance | null> {
    try {
      const { attendanceId, location, note } = params
      const now = new Date().toISOString()

      const updateData: AttendanceUpdate = {
        clock_out: now,
        clock_out_location: location ? {
          lat: location.lat,
          lng: location.lng,
          accuracy: location.accuracy,
          timestamp: now
        } : null,
        note: note || undefined
      }

      const { data, error } = await supabase
        .from('attendance')
        .update(updateData)
        .eq('id', attendanceId)
        .select()
        .single()

      if (error) throw error
      return data
    } catch (error) {
      console.error('Clock out error:', error)
      throw error
    }
  }

  /**
   * Start a break
   */
  static async startBreak(attendanceId: string): Promise<Attendance | null> {
    try {
      const now = new Date().toISOString()

      // Get current attendance
      const { data: attendance } = await supabase
        .from('attendance')
        .select('breaks')
        .eq('id', attendanceId)
        .single()

      if (!attendance) {
        throw new Error('Attendance not found')
      }

      // Add new break to breaks array
      const breaks = Array.isArray(attendance.breaks) ? attendance.breaks : []
      breaks.push({
        started_at: now
      })

      const { data, error } = await supabase
        .from('attendance')
        .update({ breaks })
        .eq('id', attendanceId)
        .select()
        .single()

      if (error) throw error
      return data
    } catch (error) {
      console.error('Start break error:', error)
      throw error
    }
  }

  /**
   * End the current break
   */
  static async endBreak(attendanceId: string): Promise<Attendance | null> {
    try {
      const now = new Date().toISOString()

      // Get current attendance
      const { data: attendance } = await supabase
        .from('attendance')
        .select('breaks, break_minutes')
        .eq('id', attendanceId)
        .single()

      if (!attendance) {
        throw new Error('Attendance not found')
      }

      const breaks = Array.isArray(attendance.breaks) ? attendance.breaks : []

      // Find the last break without ended_at
      const lastBreakIndex = breaks.findIndex((b: any) => !b.ended_at)

      if (lastBreakIndex === -1) {
        throw new Error('No active break found')
      }

      // Calculate duration
      const breakStart = new Date(breaks[lastBreakIndex].started_at)
      const breakEnd = new Date(now)
      const durationMinutes = Math.floor((breakEnd.getTime() - breakStart.getTime()) / 1000 / 60)

      // Update the break
      breaks[lastBreakIndex] = {
        ...breaks[lastBreakIndex],
        ended_at: now,
        duration_minutes: durationMinutes
      }

      // Calculate total break minutes
      const totalBreakMinutes = breaks.reduce((sum: number, b: any) => {
        return sum + (b.duration_minutes || 0)
      }, 0)

      const { data, error } = await supabase
        .from('attendance')
        .update({
          breaks,
          break_minutes: totalBreakMinutes
        })
        .eq('id', attendanceId)
        .select()
        .single()

      if (error) throw error
      return data
    } catch (error) {
      console.error('End break error:', error)
      throw error
    }
  }

  /**
   * Get current open attendance for employee
   */
  static async getCurrentAttendance(employeeId: string): Promise<Attendance | null> {
    try {
      const { data, error } = await supabase
        .from('attendance')
        .select('*')
        .eq('employee_id', employeeId)
        .eq('status', 'open')
        .is('clock_out', null)
        .order('clock_in', { ascending: false })
        .limit(1)
        .maybeSingle()

      if (error) throw error
      return data
    } catch (error) {
      console.error('Get current attendance error:', error)
      return null
    }
  }

  /**
   * Get attendance for a date range
   */
  static async getAttendanceRange(
    employeeId: string,
    startDate: string,
    endDate: string
  ): Promise<Attendance[]> {
    try {
      const { data, error } = await supabase
        .from('attendance')
        .select('*')
        .eq('employee_id', employeeId)
        .gte('date', startDate)
        .lte('date', endDate)
        .order('date', { ascending: false })

      if (error) throw error
      return data || []
    } catch (error) {
      console.error('Get attendance range error:', error)
      return []
    }
  }

  /**
   * Get week attendance (Monday to Sunday)
   */
  static async getWeekAttendance(
    employeeId: string,
    weekStartDate: string
  ): Promise<Attendance[]> {
    try {
      const weekStart = new Date(weekStartDate)
      const weekEnd = new Date(weekStart)
      weekEnd.setDate(weekEnd.getDate() + 6)

      return this.getAttendanceRange(
        employeeId,
        weekStart.toISOString().split('T')[0],
        weekEnd.toISOString().split('T')[0]
      )
    } catch (error) {
      console.error('Get week attendance error:', error)
      return []
    }
  }

  /**
   * Submit week for approval
   */
  static async submitWeek(
    employeeId: string,
    weekStartDate: string
  ): Promise<boolean> {
    try {
      const weekAttendance = await this.getWeekAttendance(employeeId, weekStartDate)

      // Update all open attendance to submitted
      const ids = weekAttendance
        .filter(a => a.status === 'open')
        .map(a => a.id)

      if (ids.length === 0) {
        return true
      }

      const { error } = await supabase
        .from('attendance')
        .update({ status: 'submitted' })
        .in('id', ids)

      if (error) throw error
      return true
    } catch (error) {
      console.error('Submit week error:', error)
      return false
    }
  }

  /**
   * Approve attendance (manager only)
   */
  static async approve(attendanceId: string): Promise<boolean> {
    try {
      const { error } = await supabase
        .from('attendance')
        .update({ status: 'approved' })
        .eq('id', attendanceId)

      if (error) throw error
      return true
    } catch (error) {
      console.error('Approve attendance error:', error)
      return false
    }
  }

  /**
   * Lock attendance (prevents further changes)
   */
  static async lock(attendanceId: string): Promise<boolean> {
    try {
      const { error } = await supabase
        .from('attendance')
        .update({ status: 'locked' })
        .eq('id', attendanceId)

      if (error) throw error
      return true
    } catch (error) {
      console.error('Lock attendance error:', error)
      return false
    }
  }

  /**
   * Get attendance for multiple employees (manager view)
   */
  static async getCompanyAttendance(
    companyId: string,
    date: string
  ): Promise<AttendanceWithEmployee[]> {
    try {
      const { data, error } = await supabase
        .from('attendance')
        .select(`
          *,
          employees:employee_id (
            id,
            first_name,
            last_name
          )
        `)
        .eq('company_id', companyId)
        .eq('date', date)
        .order('clock_in', { ascending: false })

      if (error) throw error
      return data || []
    } catch (error) {
      console.error('Get company attendance error:', error)
      return []
    }
  }
}
