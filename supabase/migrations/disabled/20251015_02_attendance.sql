-- Migration: Attendance Table (Arbeitszeit/Anwesenheit)
-- Purpose: Track employee work shifts independent of project time
-- Idempotent: Can be run multiple times safely

-- ============================================================================
-- 1. CREATE ATTENDANCE TABLE
-- ============================================================================

CREATE TABLE IF NOT EXISTS public.attendance (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,

  -- References
  employee_id UUID NOT NULL REFERENCES public.employees(id) ON DELETE CASCADE,
  company_id UUID REFERENCES public.companies(id) ON DELETE CASCADE,

  -- Date and times
  date DATE NOT NULL,
  clock_in TIMESTAMP WITH TIME ZONE NOT NULL,
  clock_out TIMESTAMP WITH TIME ZONE,

  -- Break time (aggregated, in minutes)
  break_minutes INTEGER DEFAULT 0 CHECK (break_minutes >= 0),

  -- Break details (stored as JSONB for flexibility)
  -- Example: [{"started_at": "...", "ended_at": "...", "duration_minutes": 30}]
  breaks JSONB DEFAULT '[]'::jsonb,

  -- Calculated work time (in minutes, excluding breaks)
  work_minutes INTEGER GENERATED ALWAYS AS (
    CASE
      WHEN clock_out IS NOT NULL THEN
        GREATEST(0, EXTRACT(EPOCH FROM (clock_out - clock_in))::INTEGER / 60 - break_minutes)
      ELSE NULL
    END
  ) STORED,

  -- Status workflow
  status TEXT NOT NULL DEFAULT 'open' CHECK (
    status IN ('open', 'submitted', 'approved', 'locked', 'rejected')
  ),

  -- GPS locations (optional)
  clock_in_location JSONB, -- {lat, lng, accuracy, timestamp}
  clock_out_location JSONB,

  -- Notes
  note TEXT,

  -- Flag for migration (auto-generated from old time_entries)
  autogenerated BOOLEAN DEFAULT false,

  -- Metadata
  created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,
  created_by UUID REFERENCES auth.users(id),
  updated_by UUID REFERENCES auth.users(id),

  -- Business rules
  CONSTRAINT valid_clock_times CHECK (clock_out IS NULL OR clock_out > clock_in),
  CONSTRAINT unique_attendance_per_employee_date UNIQUE (employee_id, date)
);

-- ============================================================================
-- 2. CREATE INDEXES
-- ============================================================================

CREATE INDEX IF NOT EXISTS idx_attendance_employee_date ON public.attendance(employee_id, date DESC);
CREATE INDEX IF NOT EXISTS idx_attendance_company ON public.attendance(company_id);
CREATE INDEX IF NOT EXISTS idx_attendance_status ON public.attendance(status) WHERE status = 'open';
CREATE INDEX IF NOT EXISTS idx_attendance_date_range ON public.attendance(date DESC);
CREATE INDEX IF NOT EXISTS idx_attendance_autogenerated ON public.attendance(autogenerated) WHERE autogenerated = true;

-- ============================================================================
-- 3. ENABLE RLS
-- ============================================================================

ALTER TABLE public.attendance ENABLE ROW LEVEL SECURITY;

-- Employees can view their own attendance
CREATE POLICY IF NOT EXISTS "Employees can view own attendance" ON public.attendance
  FOR SELECT
  USING (
    EXISTS (
      SELECT 1 FROM employees
      WHERE employees.id = attendance.employee_id
      AND employees.user_id = auth.uid()
    )
  );

-- Employees can create their own attendance
CREATE POLICY IF NOT EXISTS "Employees can create own attendance" ON public.attendance
  FOR INSERT
  WITH CHECK (
    EXISTS (
      SELECT 1 FROM employees
      WHERE employees.id = attendance.employee_id
      AND employees.user_id = auth.uid()
    )
  );

-- Employees can update their own attendance (only if not locked)
CREATE POLICY IF NOT EXISTS "Employees can update own attendance" ON public.attendance
  FOR UPDATE
  USING (
    EXISTS (
      SELECT 1 FROM employees
      WHERE employees.id = attendance.employee_id
      AND employees.user_id = auth.uid()
    )
    AND status NOT IN ('locked', 'approved')
  );

-- Managers can view all attendance in their company
CREATE POLICY IF NOT EXISTS "Managers can view company attendance" ON public.attendance
  FOR SELECT
  USING (
    EXISTS (
      SELECT 1 FROM employees
      WHERE employees.user_id = auth.uid()
      AND employees.company_id = attendance.company_id
      AND employees.role IN ('manager', 'admin')
    )
  );

-- Managers can approve/lock attendance
CREATE POLICY IF NOT EXISTS "Managers can manage company attendance" ON public.attendance
  FOR UPDATE
  USING (
    EXISTS (
      SELECT 1 FROM employees
      WHERE employees.user_id = auth.uid()
      AND employees.company_id = attendance.company_id
      AND employees.role IN ('manager', 'admin')
    )
  );

-- ============================================================================
-- 4. TRIGGERS
-- ============================================================================

-- Updated_at trigger
CREATE OR REPLACE FUNCTION update_attendance_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = timezone('utc'::text, now());
  NEW.updated_by = auth.uid();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_attendance_updated_at_trigger
  BEFORE UPDATE ON public.attendance
  FOR EACH ROW
  EXECUTE FUNCTION update_attendance_updated_at();

-- Prevent modification of locked attendance
CREATE OR REPLACE FUNCTION prevent_locked_attendance_modification()
RETURNS TRIGGER AS $$
BEGIN
  IF OLD.status = 'locked' AND NEW.status != 'locked' THEN
    RAISE EXCEPTION 'Cannot modify locked attendance record. ID: %', OLD.id
      USING ERRCODE = 'check_violation';
  END IF;

  IF OLD.status = 'locked' AND (
    NEW.clock_in != OLD.clock_in OR
    NEW.clock_out IS DISTINCT FROM OLD.clock_out OR
    NEW.break_minutes != OLD.break_minutes
  ) THEN
    RAISE EXCEPTION 'Cannot modify times of locked attendance. ID: %', OLD.id
      USING ERRCODE = 'check_violation';
  END IF;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER prevent_locked_attendance_modification_trigger
  BEFORE UPDATE ON public.attendance
  FOR EACH ROW
  EXECUTE FUNCTION prevent_locked_attendance_modification();

-- Validate no overlapping attendance for same employee
CREATE OR REPLACE FUNCTION check_attendance_overlap()
RETURNS TRIGGER AS $$
BEGIN
  -- Only check if clock_out is set
  IF NEW.clock_out IS NOT NULL THEN
    IF EXISTS (
      SELECT 1 FROM attendance
      WHERE employee_id = NEW.employee_id
      AND id != COALESCE(NEW.id, gen_random_uuid())
      AND clock_out IS NOT NULL
      AND (
        -- New attendance overlaps with existing
        (NEW.clock_in >= clock_in AND NEW.clock_in < clock_out) OR
        (NEW.clock_out > clock_in AND NEW.clock_out <= clock_out) OR
        (NEW.clock_in <= clock_in AND NEW.clock_out >= clock_out)
      )
    ) THEN
      RAISE EXCEPTION 'Attendance overlap detected for employee % on date %',
        NEW.employee_id, NEW.date
        USING ERRCODE = 'check_violation';
    END IF;
  END IF;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER check_attendance_overlap_trigger
  BEFORE INSERT OR UPDATE ON public.attendance
  FOR EACH ROW
  EXECUTE FUNCTION check_attendance_overlap();

-- ============================================================================
-- 5. HELPER FUNCTIONS
-- ============================================================================

-- Get current open attendance for employee
CREATE OR REPLACE FUNCTION get_current_attendance(p_employee_id UUID)
RETURNS TABLE (
  id UUID,
  date DATE,
  clock_in TIMESTAMPTZ,
  clock_out TIMESTAMPTZ,
  break_minutes INTEGER,
  work_minutes INTEGER,
  status TEXT
)
LANGUAGE sql
SECURITY DEFINER
AS $$
  SELECT id, date, clock_in, clock_out, break_minutes, work_minutes, status
  FROM attendance
  WHERE employee_id = p_employee_id
  AND status = 'open'
  AND clock_out IS NULL
  ORDER BY clock_in DESC
  LIMIT 1;
$$;

-- ============================================================================
-- 6. COMMENTS
-- ============================================================================

COMMENT ON TABLE public.attendance IS 'Employee attendance/work shifts (Arbeitszeit) - independent of project time';
COMMENT ON COLUMN public.attendance.work_minutes IS 'Calculated: (clock_out - clock_in) - break_minutes, in minutes';
COMMENT ON COLUMN public.attendance.breaks IS 'Array of break periods: [{"started_at", "ended_at", "duration_minutes"}]';
COMMENT ON COLUMN public.attendance.autogenerated IS 'True if generated from legacy time_entries during migration';
COMMENT ON COLUMN public.attendance.status IS 'Workflow: open → submitted → approved → locked';

-- ============================================================================
-- VERIFICATION QUERY (run after migration)
-- ============================================================================
-- SELECT * FROM attendance LIMIT 5;
-- SELECT get_current_attendance('<employee_id>');
