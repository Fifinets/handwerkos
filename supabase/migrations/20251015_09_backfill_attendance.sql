-- Migration: Backfill Attendance from existing time_entries
-- Purpose: Generate attendance records from historical project time data
-- IMPORTANT: Idempotent - can be run multiple times without duplicates
-- Strategy: For each employee+date, create attendance from min(start) to max(end)

-- ============================================================================
-- 1. BACKFILL FUNCTION (Idempotent)
-- ============================================================================

CREATE OR REPLACE FUNCTION backfill_attendance_from_time_entries(
  p_start_date DATE DEFAULT NULL,
  p_end_date DATE DEFAULT NULL,
  p_employee_id UUID DEFAULT NULL,
  p_dry_run BOOLEAN DEFAULT false
)
RETURNS TABLE (
  action TEXT,
  employee_id UUID,
  date DATE,
  clock_in TIMESTAMPTZ,
  clock_out TIMESTAMPTZ,
  break_minutes INTEGER,
  work_minutes INTEGER,
  message TEXT
)
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_count INTEGER := 0;
  v_skipped INTEGER := 0;
  v_start_time TIMESTAMPTZ;
BEGIN
  v_start_time := clock_timestamp();

  -- Set defaults for date range if not specified
  p_start_date := COALESCE(p_start_date, CURRENT_DATE - INTERVAL '90 days');
  p_end_date := COALESCE(p_end_date, CURRENT_DATE);

  RAISE NOTICE 'Starting backfill from % to % (dry_run: %)', p_start_date, p_end_date, p_dry_run;

  -- Insert attendance records for each employee+date with time_entries
  FOR employee_id, date, clock_in, clock_out, break_minutes, work_minutes IN
    SELECT
      te.employee_id,
      te.start_time::date AS date,
      MIN(te.start_time) AS clock_in,
      MAX(COALESCE(te.end_time, te.start_time + INTERVAL '8 hours')) AS clock_out,
      COALESCE(SUM(te.break_duration), 0)::INTEGER AS break_minutes,
      NULL::INTEGER AS work_minutes -- Will be calculated by attendance table
    FROM time_entries te
    WHERE te.start_time::date >= p_start_date
      AND te.start_time::date <= p_end_date
      AND (p_employee_id IS NULL OR te.employee_id = p_employee_id)
      AND te.end_time IS NOT NULL -- Only completed entries
    GROUP BY te.employee_id, te.start_time::date
  LOOP
    -- Check if attendance already exists
    IF EXISTS (
      SELECT 1 FROM attendance a
      WHERE a.employee_id = backfill_attendance_from_time_entries.employee_id
      AND a.date = backfill_attendance_from_time_entries.date
    ) THEN
      v_skipped := v_skipped + 1;

      -- Return skipped record
      RETURN QUERY SELECT
        'SKIPPED'::TEXT,
        backfill_attendance_from_time_entries.employee_id,
        backfill_attendance_from_time_entries.date,
        backfill_attendance_from_time_entries.clock_in,
        backfill_attendance_from_time_entries.clock_out,
        backfill_attendance_from_time_entries.break_minutes,
        NULL::INTEGER,
        'Attendance already exists'::TEXT;

      CONTINUE;
    END IF;

    -- Insert (if not dry-run)
    IF NOT p_dry_run THEN
      INSERT INTO attendance (
        employee_id,
        company_id,
        date,
        clock_in,
        clock_out,
        break_minutes,
        status,
        autogenerated,
        note
      )
      SELECT
        backfill_attendance_from_time_entries.employee_id,
        e.company_id,
        backfill_attendance_from_time_entries.date,
        backfill_attendance_from_time_entries.clock_in,
        backfill_attendance_from_time_entries.clock_out,
        backfill_attendance_from_time_entries.break_minutes,
        'submitted'::TEXT, -- Auto-mark as submitted
        true, -- autogenerated flag
        'Migrated from time_entries'::TEXT
      FROM employees e
      WHERE e.id = backfill_attendance_from_time_entries.employee_id;
    END IF;

    v_count := v_count + 1;

    -- Return created record
    RETURN QUERY SELECT
      CASE WHEN p_dry_run THEN 'DRY_RUN' ELSE 'CREATED' END::TEXT,
      backfill_attendance_from_time_entries.employee_id,
      backfill_attendance_from_time_entries.date,
      backfill_attendance_from_time_entries.clock_in,
      backfill_attendance_from_time_entries.clock_out,
      backfill_attendance_from_time_entries.break_minutes,
      EXTRACT(EPOCH FROM (backfill_attendance_from_time_entries.clock_out - backfill_attendance_from_time_entries.clock_in))::INTEGER / 60 - backfill_attendance_from_time_entries.break_minutes AS work_minutes,
      format('Created from %s time entries', (
        SELECT COUNT(*)
        FROM time_entries te2
        WHERE te2.employee_id = backfill_attendance_from_time_entries.employee_id
        AND te2.start_time::date = backfill_attendance_from_time_entries.date
      ))::TEXT;
  END LOOP;

  -- Log summary
  RAISE NOTICE 'Backfill complete: % created, % skipped (execution time: %)',
    v_count, v_skipped, clock_timestamp() - v_start_time;

  -- Insert audit log entry (if not dry-run)
  IF NOT p_dry_run THEN
    INSERT INTO time_audit_log (
      entity_type,
      entity_id,
      action,
      new_values,
      reason
    ) VALUES (
      'attendance',
      gen_random_uuid(),
      'created',
      jsonb_build_object(
        'records_created', v_count,
        'records_skipped', v_skipped,
        'start_date', p_start_date,
        'end_date', p_end_date,
        'employee_id', p_employee_id
      ),
      'Automatic backfill from time_entries'
    );
  END IF;
END;
$$;

-- ============================================================================
-- 2. GAP DETECTION FUNCTION
-- ============================================================================

CREATE OR REPLACE FUNCTION detect_attendance_gaps(
  p_employee_id UUID,
  p_date DATE
)
RETURNS TABLE (
  gap_start TIMESTAMPTZ,
  gap_end TIMESTAMPTZ,
  gap_minutes INTEGER,
  suggested_cost_center TEXT,
  reason TEXT
)
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  RETURN QUERY
  WITH
    -- Get attendance for the day
    day_attendance AS (
      SELECT clock_in, clock_out
      FROM attendance
      WHERE employee_id = p_employee_id
      AND date = p_date
      AND clock_out IS NOT NULL
    ),
    -- Get all time entries for the day
    day_entries AS (
      SELECT start_time, end_time
      FROM time_entries
      WHERE employee_id = p_employee_id
      AND start_time::date = p_date
      AND end_time IS NOT NULL
      ORDER BY start_time
    ),
    -- Calculate covered ranges
    covered_ranges AS (
      SELECT
        start_time AS range_start,
        end_time AS range_end
      FROM day_entries
    )
  -- Find gaps
  SELECT
    CASE
      WHEN lag(range_end) OVER (ORDER BY range_start) IS NULL
      THEN (SELECT clock_in FROM day_attendance)
      ELSE lag(range_end) OVER (ORDER BY range_start)
    END AS gap_start,
    range_start AS gap_end,
    EXTRACT(EPOCH FROM (
      range_start - COALESCE(
        lag(range_end) OVER (ORDER BY range_start),
        (SELECT clock_in FROM day_attendance)
      )
    ))::INTEGER / 60 AS gap_minutes,
    CASE
      WHEN EXTRACT(EPOCH FROM (range_start - COALESCE(lag(range_end) OVER (ORDER BY range_start), (SELECT clock_in FROM day_attendance))))::INTEGER / 60 > 60
      THEN 'WERKSTATT'
      WHEN EXTRACT(HOUR FROM range_start) >= 11 AND EXTRACT(HOUR FROM range_start) <= 13
      THEN 'BREAK'
      ELSE 'WERKSTATT'
    END AS suggested_cost_center,
    'Unaccounted time detected' AS reason
  FROM covered_ranges
  WHERE EXTRACT(EPOCH FROM (
    range_start - COALESCE(
      lag(range_end) OVER (ORDER BY range_start),
      (SELECT clock_in FROM day_attendance)
    )
  ))::INTEGER / 60 > 15; -- Only gaps > 15 minutes
END;
$$;

-- ============================================================================
-- 3. RECONCILIATION CHECK FUNCTION
-- ============================================================================

CREATE OR REPLACE FUNCTION check_reconciliation(
  p_employee_id UUID,
  p_date DATE
)
RETURNS TABLE (
  status TEXT,
  attendance_minutes INTEGER,
  project_minutes INTEGER,
  cost_center_minutes INTEGER,
  break_minutes INTEGER,
  total_accounted_minutes INTEGER,
  coverage_percent DECIMAL,
  difference_minutes INTEGER,
  is_within_tolerance BOOLEAN
)
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_attendance_minutes INTEGER;
  v_project_minutes INTEGER;
  v_cost_center_minutes INTEGER;
  v_break_minutes INTEGER;
  v_total_accounted INTEGER;
  v_coverage_percent DECIMAL;
  v_difference INTEGER;
  v_tolerance DECIMAL;
  v_is_within_tolerance BOOLEAN;
  v_company_id UUID;
BEGIN
  -- Get company and tolerance
  SELECT e.company_id, tr.reconciliation_tolerance_percent
  INTO v_company_id, v_tolerance
  FROM employees e
  LEFT JOIN time_rules tr ON tr.company_id = e.company_id AND tr.is_active = true
  WHERE e.id = p_employee_id
  LIMIT 1;

  v_tolerance := COALESCE(v_tolerance, 5.00);

  -- Get attendance work minutes
  SELECT COALESCE(work_minutes, 0)
  INTO v_attendance_minutes
  FROM attendance
  WHERE employee_id = p_employee_id
  AND date = p_date
  AND clock_out IS NOT NULL;

  -- Get project time
  SELECT COALESCE(SUM(EXTRACT(EPOCH FROM (end_time - start_time))::INTEGER / 60), 0)
  INTO v_project_minutes
  FROM time_entries
  WHERE employee_id = p_employee_id
  AND start_time::date = p_date
  AND type = 'project'
  AND end_time IS NOT NULL;

  -- Get cost center time
  SELECT COALESCE(SUM(EXTRACT(EPOCH FROM (end_time - start_time))::INTEGER / 60), 0)
  INTO v_cost_center_minutes
  FROM time_entries
  WHERE employee_id = p_employee_id
  AND start_time::date = p_date
  AND type = 'cost_center'
  AND end_time IS NOT NULL;

  -- Get break minutes from attendance
  SELECT COALESCE(break_minutes, 0)
  INTO v_break_minutes
  FROM attendance
  WHERE employee_id = p_employee_id
  AND date = p_date;

  -- Calculate totals
  v_total_accounted := v_project_minutes + v_cost_center_minutes + v_break_minutes;

  IF v_attendance_minutes > 0 THEN
    v_coverage_percent := ROUND((v_total_accounted::DECIMAL / v_attendance_minutes::DECIMAL) * 100, 2);
    v_difference := v_attendance_minutes - v_total_accounted;
    v_is_within_tolerance := ABS(v_difference) <= (v_attendance_minutes * v_tolerance / 100);
  ELSE
    v_coverage_percent := 0;
    v_difference := 0;
    v_is_within_tolerance := false;
  END IF;

  -- Determine status
  RETURN QUERY SELECT
    CASE
      WHEN v_coverage_percent >= 95 THEN 'green'
      WHEN v_coverage_percent >= 90 THEN 'yellow'
      ELSE 'red'
    END::TEXT,
    v_attendance_minutes,
    v_project_minutes,
    v_cost_center_minutes,
    v_break_minutes,
    v_total_accounted,
    v_coverage_percent,
    v_difference,
    v_is_within_tolerance;
END;
$$;

-- ============================================================================
-- 4. COMMENTS
-- ============================================================================

COMMENT ON FUNCTION backfill_attendance_from_time_entries IS 'Idempotent function to create attendance records from time_entries. Use dry_run=true to preview.';
COMMENT ON FUNCTION detect_attendance_gaps IS 'Find unaccounted time gaps between clock-in/out and project time';
COMMENT ON FUNCTION check_reconciliation IS 'Calculate coverage and reconciliation status for a date';

-- ============================================================================
-- 5. EXAMPLE USAGE
-- ============================================================================

-- DRY RUN: Preview what would be created
-- SELECT * FROM backfill_attendance_from_time_entries(
--   p_start_date := '2025-01-01',
--   p_end_date := '2025-10-15',
--   p_dry_run := true
-- );

-- ACTUAL RUN: Create attendance records
-- SELECT * FROM backfill_attendance_from_time_entries(
--   p_start_date := '2025-01-01',
--   p_end_date := '2025-10-15',
--   p_dry_run := false
-- );

-- CHECK GAPS for specific employee+date
-- SELECT * FROM detect_attendance_gaps('<employee_id>', '2025-10-15');

-- CHECK RECONCILIATION
-- SELECT * FROM check_reconciliation('<employee_id>', '2025-10-15');

-- ============================================================================
-- VERIFICATION QUERIES
-- ============================================================================
-- SELECT COUNT(*) FROM attendance WHERE autogenerated = true;
-- SELECT employee_id, COUNT(*) FROM attendance WHERE autogenerated = true GROUP BY employee_id;
